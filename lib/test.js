// Generated by CoffeeScript 1.7.1
(function() {
  var TRM, alert, badge, consumer, debug, echo, help, info, log, rpr, urge, warn, whisper,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'STEP';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  this.__chain = function(stepper_1, stepper_2, handler) {
    return stepper_1(stepper_2, (function(_this) {
      return function() {
        var P, error;
        error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (error != null) {
          return handler(error);
        }
        return handler.apply(null, [null].concat(__slice.call(P)));
      };
    })(this));
  };

  this._chain = function(stepper_1, stepper_2, handler) {
    return function() {
      return stepper_1(stepper_2, (function(_this) {
        return function() {
          var P, error;
          error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (error != null) {
            return handler(error);
          }
          return handler.apply(null, [null].concat(__slice.call(P)));
        };
      })(this));
    };
  };

  this.chain = function() {
    var handler, next, stepper, steppers, _i, _j, _len, _results;
    steppers = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), handler = arguments[_i++];
    if (!(steppers.length > 0)) {
      return handler(new Error("expected at least one stepper, got none"));
    }
    if (steppers.length === 1) {
      return steppers[0];
    }
    next = (function(_this) {
      return function() {
        var P;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return handler.apply(null, P);
      };
    })(this);
    _results = [];
    for (_j = 0, _len = steppers.length; _j < _len; _j++) {
      stepper = steppers[_j];
      _results.push(next = this._chain(stepper, next));
    }
    return _results;
  };

  consumer = function() {
    var STEP, f, g, h, i;
    STEP = this;
    f = function(handler) {
      return STEP.triplets(source_stepper, (function(_this) {
        return function(error, last_value, this_value, next_value) {
          return handler(null, last_value, this_value, next_value);
        };
      })(this));
    };
    g = function(handler) {
      return STEP.indexed(f, function() {
        var P, error;
        error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return handler.apply(null, [null].concat(__slice.call(P)));
      });
    };
    h = function(handler) {
      return STEP.reversed(g, function() {
        var P, error;
        error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return handler.apply(null, [null].concat(__slice.call(P)));
      });
    };
    i = function(handler) {
      return STEP.tabled(h, function(error, table_rpr) {
        return urge(table_rpr);
      });
    };
    i();
    f = function(handler) {
      return STEP.fenced(source_stepper, '(', ')', function() {
        var P, error;
        error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (error != null) {
          throw error;
        }
        return handler.apply(null, [null].concat(__slice.call(P)));
      });
    };
    return STEP.__chain(STEP.indexed, f, function(error, idx, value) {
      if (error != null) {
        throw error;
      }
      return log(TRM.grey(idx), TRM.lime(value));
    });
  };

}).call(this);
